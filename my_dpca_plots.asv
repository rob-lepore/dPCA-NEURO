clear;
clc;
close all;

%% Execute DPCA

% From D_dpca_Reaching.m 

% File to load/save dPCA results
data_save_file = "my_dpca_data";
load_from_file = true; % If true, skip dPCA and load from file above

if ~load_from_file
    data_Path = 'C:\Users\rober\OneDrive\Documents\Uni\Bioinformatics\Neurosciences\project\V6A_mef24\V6A_mef24\';
    cells_in_Directory = dir(data_Path);
    cells_in_Directory ([1,2],:) = [];
    
    event_Name = 'Saccade-Off';    
    dataname = 'V6A_mef24 - Saccade-Off';
    time_Window = [200,3200];
    sDF_bin_Size = 100;              
    ifSimultaneousRecording = true;  
   
    % Compute firing rates
    [firingRates, trialNum] = A_general_calculate_firing_rates_dpca(data_Path, cells_in_Directory, time_Window, sDF_bin_Size, event_Name);
    trialNum = squeeze(trialNum(:,:,1));
    % Pick NEAR hand position only and average over trials
    firingRates = squeeze(firingRates(:,:,1,:,:));
    firingRatesAverage = mean(firingRates, 4);

    disp(['dPCA with regularization'])
    
    combinedParams = {{1, [1 2]}, {2}};
    num_comp = 15;
    optimalLambda = dpca_optimizeLambda(firingRatesAverage, firingRates, trialNum, dataname, ...
        'combinedParams', combinedParams, ...
        'simultaneous', ifSimultaneousRecording, ...
        'numRep', 10, ...
        'filename', 'tmp_optimalLambdas.mat', ...
        'display', false);
    
    Cnoise = dpca_getNoiseCovariance(firingRatesAverage, ...
        firingRates, trialNum, 'simultaneous', ifSimultaneousRecording);
    
    [W,V,whichMarg] = dpca(firingRatesAverage, num_comp, ...
        'combinedParams', combinedParams, ...
        'lambda', optimalLambda, ...
        'Cnoise', Cnoise);

    explVar = dpca_explainedVariance(firingRatesAverage, W, V, ...
    'combinedParams', combinedParams);

    if data_save_file~=""
        save(data_save_file, "W", "V", "whichMarg","firingRatesAverage", "num_comp", "explVar");
    end
else
    if data_save_file~=""
        load(data_save_file);
    else
        disp(['Error: choose a file to load data from']);
        return;
    end
end

timeMarg = find(whichMarg == 2); 
timeMargExplVar = explVar.componentVar(timeMarg);

[num_neurons, num_stimuli, num_time_points] = size(firingRatesAverage);

epochNames = {'Fixation', 'Plan', 'Reach', 'Hold'};
epochTimes = [1 1000; 1631 2331; 2332 2592; 2593 3392];

% Decode into dPCs
X = firingRatesAverage(:,:)';
global_neuron_mean = mean(X, 1);
Xcen = bsxfun(@minus, X, global_neuron_mean);
dPCs = Xcen * W;
g_means = mean(dPCs, 1);                               
g_stds  = std(dPCs, 0, 1); 

%% Gradient maps

nInterp = 100;           % resolution for smooth interpolation
colorRange = [-2 2]; % fixed color range for all plots
nRows = length(timeMarg);  % number of components
nCols = length(epochTimes); % number of epochs

figure('Position', [100 100 1200 900]);

for j = 1:nRows
    marg = timeMarg(j);  % current component

    for i = 1:nCols
        epochTime = epochTimes(i,:);
        nmsc_3x3 = stimuli_grid_dpca(firingRatesAverage, W, ...
                                     epochTime(1), epochTime(2), marg, ...
                                     global_neuron_mean, g_means, g_stds);

        % --- Smooth interpolation ---
        [X, Y] = meshgrid(1:3, 1:3);
        [XX, YY] = meshgrid(linspace(1,3,nInterp), linspace(1,3,nInterp));
        interp_values = interp2(X, Y, nmsc_3x3, XX, YY, 'linear');

        % --- Plot in the correct subplot ---
        subplot(nRows, nCols, (j-1)*nCols + i);
        imagesc(interp_values, colorRange);
        colormap(jet);  % or your custom colormap
        axis square;
        axis xy;
        set(gca, 'XTick', [], 'YTick', []);

        % Title only for first row
        if j == 1
            title(epochNames{i}, 'FontSize', 12);
        end

        % Label rows with component number
        if i == 1
            ylabel(sprintf('Comp %d', marg), 'FontSize', 12);
        end
    end
end


%% Exaplained variance %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Bar plot with projected variances
figure('Position', [100,-50,645,328]);
axBar = subplot(1,1,1);
hold on
axis([0 num_comp+1 0 12.5])
ylabel('Component variance (%)')
xlabel('Number of components')
b = bar(explVar.margVar(:,1:num_comp)' , 'stacked', 'BarWidth', 0.75);

margColours = [23 100 171; 187 20 25; 150 150 150; 114 97 171]/256;

for idx = 1:numel(b)
    b(idx).FaceColor = margColours(idx,:);
end 

clim([1 length(margColours)+256]);
set(gca, 'FontSize', 14);

% Pie chart with total explained variance
figure;
axPie = subplot(1,1,1);

d = explVar.totalMarginalizedVar / explVar.totalVar * 100;
roundedD = floor(d);
while sum(roundedD) < 100
    [~, ind] = max(d-roundedD);
    roundedD(ind) = roundedD(ind) + 1;
end

margColours = [23 100 171; 187 20 25; 150 150 150; 114 97 171]/256;
margNames = {'Target', 'Condition-independent'};

for i=1:length(d)
    margNamesPerc{i} = [margNames{i} ' ' num2str(roundedD(i)) '%'];
end

p = pie(d, ones(size(d)));

for k = 1:length(p)
    if strcmp(get(p(k), 'Type'), 'text')
        set(p(k), 'String', ''); % Hide the text
    end
end

% Set colors
numSegments = length(d);
numColours = size(margColours, 1);
for k = 1:numSegments
    if strcmp(get(p(2*k-1), 'Type'), 'patch') 
        colorIndex = mod(k-1, numColours) + 1; 
        set(p(2*k-1), 'FaceColor', margColours(colorIndex, :));
    end
end

lgd = legend(margNamesPerc, 'Location', 'bestoutside');
set(lgd, 'FontSize', 14);


%% Scatter Plot %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
scatterdata = zeros(n_comp, nEpochs, num_stimuli);

for j = 1:nCompsSel
    compIdx = timeMarg(j);           % actual component index in W / g_means / g_stds

    for ei = 1:nEpochs
        t0 = epochTimes(ei,1);
        t1 = epochTimes(ei,2);

        % --- get epoch and flatten to (S*T) x neurons ---
        epochData = firingRatesAverage(:,:,t0:t1);     % neurons x stimuli x T_e
        X = reshape(epochData, num_neurons, [])';     % (stimuli*time) x neurons

        % --- center with global mean and project using W ---
        Xcen = bsxfun(@minus, X, global_neuron_mean); % (S*T) x neurons
        Zcol = Xcen * W(:, compIdx);                  % (S*T) x 1  <-- single component column

        % --- reshape to stimuli x time and average across time ---
        Zmat = reshape(Zcol, num_stimuli, []);       % stimuli x time
        meanSpikeCount = mean(Zmat, 2);              % stimuli x 1

        % --- normalize with global stats (handle zero std) ---
        if g_stds(compIdx) == 0
            normalized = zeros(size(meanSpikeCount));
        else
            normalized = (meanSpikeCount - g_means(compIdx)) ./ g_stds(compIdx);
        end

        % store: comp j, epoch ei, all stimuli
        scatterdata(j, ei, :) = normalized(:)';
    end
end

colors = [
    0.8500, 0.3250, 0.0980;  
    0.9290, 0.6940, 0.1250;  
    0.4940, 0.1840, 0.5560;  
    0.4660, 0.6740, 0.1880;  
    0.3010, 0.7450, 0.9330;  
    0.6350, 0.0780, 0.1840;  
    0.0000, 0.4470, 0.7410;  
    0.8500, 0.3250, 0.7980;  
    0.8, 0.6, 0.4;           
];


fig = figure("Position",[0 0 1660 468]);


for plotIdx = 1:4
    subplot(1, 4, plotIdx);
    hold on;
    for catIdx = 1:4
        for valIdx = 1:9
            value = scatterdata(plotIdx, catIdx, valIdx);
            scatter(catIdx, value, 80, colors(valIdx, :), 'filled');
        end
    end
    xticks(1:4);  
    xticklabels(epochNames);
    yticks(floor(min(scatterdata(:))):ceil(max(scatterdata(:))));
    title(sprintf("dPC #%d [%.1f %%]", timeMarg(plotIdx),  timeMargExplVar(plotIdx)))
    ylim([-3, 3]);
    if plotIdx == 1
        ylabel("Norm. spk count");
    end

    axis square;
    set(gca, 'FontSize', 14);
    hold off;
end

hold off;




%% scatter legend
x = [1, 2, 3]; % 1: Left, 2: Center, 3: Right
y = [1, 2, 3]; % 1: Near, 2: Intermediate, 3: Far
figure;
hold on;

index = 1;
for i = 1:3
    for j = 1:3
        plot(x(j), y(i), 'o', 'MarkerSize', 10, 'MarkerEdgeColor', colors(index, :), 'MarkerFaceColor', colors(index, :));
        index = index + 1;
    end
end

% Set the axis limits
xlim([0.5 3.5]);
ylim([0.5 3.5]);

% Set the axis labels
set(gca, 'XTick', [1, 2, 3], 'XTickLabel', {'Left', 'Center', 'Right'});
set(gca, 'YTick', [1, 2, 3], 'YTickLabel', {'Near', 'Intermediate', 'Far'});

% Add grid lines
grid on;

hold off;